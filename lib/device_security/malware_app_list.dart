import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:freerasp/freerasp.dart';
import 'threat_state.dart';
import 'package:malwirus/theme/app_colors.dart';

class MalwareAppList extends StatefulWidget {
  final List<SuspiciousAppInfo> initialApps;
  final ScrollController? scrollController;
  const MalwareAppList({Key? key, required this.initialApps, this.scrollController}) : super(key: key);

  @override
  State<MalwareAppList> createState() => _MalwareAppListState();
}

class _MalwareAppListState extends State<MalwareAppList> with WidgetsBindingObserver {
  final Map<String, Uint8List?> _iconCache = {};
  bool _iconsLoading = false;

  late List<SuspiciousAppInfo> _apps;
  static const platform = MethodChannel('com.zrelxr06.malwirus/sms_security');

  @override
  void initState() {
    super.initState();
    _apps = List.from(widget.initialApps);
    WidgetsBinding.instance.addObserver(this);
    _fetchAllIcons();
  }

  Future<void> _fetchAllIcons() async {
    setState(() {
      _iconsLoading = true;
    });
    for (final app in _apps) {
      if (!_iconCache.containsKey(app.packageInfo.packageName)) {
        final iconStr = await Talsec.instance.getAppIcon(app.packageInfo.packageName);
        _iconCache[app.packageInfo.packageName] = iconStr != null ? base64.decode(iconStr) : null;
      }
    }
    if (mounted) {
      setState(() {
        _iconsLoading = false;
      });
    }
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    super.dispose();
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) async {
    if (state == AppLifecycleState.resumed) {
      // On resume, check all apps quickly
      List<SuspiciousAppInfo> stillInstalled = [];
      for (final app in _apps) {
        final exists = await platform.invokeMethod<bool>('checkAppInstalled', {'packageName': app.packageInfo.packageName});
        if (exists == true) stillInstalled.add(app);
      }
      if (mounted && stillInstalled.length != _apps.length) {
        setState(() {
          _apps = stillInstalled;
        });
      }
    }
  }

  Future<void> _openAppInfoAndCheck(String packageName, int index) async {
    try {
      await platform.invokeMethod('openAppInfo', {'packageName': packageName});
      // Wait for user to possibly uninstall, then check if still installed
      await Future.delayed(const Duration(seconds: 2));
      final exists = await platform.invokeMethod<bool>('checkAppInstalled', {'packageName': packageName});
      if (exists == false) {
        setState(() {
          _apps.removeAt(index);
        });
      }
    } catch (e) {
      debugPrint('Error opening/checking app info: $e');
    }
  }

  @override
  Widget build(BuildContext context) {
    final isDarkMode = Theme.of(context).brightness == Brightness.dark;
    if (_apps.isEmpty) {
      return Center(
        child: Text(
          'No suspicious apps detected.',
          style: TextStyle(color: isDarkMode ? Colors.white54 : Colors.black54),
        ),
      );
    }
    if (_iconsLoading) {
      return const Center(child: CircularProgressIndicator());
    }
    return ListView.builder(
      controller: widget.scrollController,
      itemCount: _apps.length,
      itemBuilder: (_, index) {
        final malware = _apps[index];
        final iconBytes = _iconCache[malware.packageInfo.packageName];
        Widget appIcon;
        if (iconBytes != null) {
          appIcon = Image.memory(iconBytes);
        } else {
          appIcon = const Icon(Icons.error, color: Colors.red);
        }
        return ListTile(
          key: ValueKey(malware.packageInfo.packageName),
          title: Text(malware.packageInfo.packageName),
          subtitle: Text('Reason: ${malware.reason}'),
          leading: appIcon,
          trailing: const Icon(Icons.arrow_forward_ios, size: 16),
          onTap: () => _openAppInfoAndCheck(malware.packageInfo.packageName, index),
        );
      },
    );
  }
}
